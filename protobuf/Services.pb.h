// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Services.proto

#ifndef PROTOBUF_Services_2eproto__INCLUDED
#define PROTOBUF_Services_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Services_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsTxtFieldImpl();
void InitDefaultsTxtField();
void InitDefaultsServiceRequest_Register_LocationImpl();
void InitDefaultsServiceRequest_Register_Location();
void InitDefaultsServiceRequest_RegisterImpl();
void InitDefaultsServiceRequest_Register();
void InitDefaultsServiceRequest_UnregisterImpl();
void InitDefaultsServiceRequest_Unregister();
void InitDefaultsServiceRequest_FindImpl();
void InitDefaultsServiceRequest_Find();
void InitDefaultsServiceRequestImpl();
void InitDefaultsServiceRequest();
void InitDefaultsServiceReply_FindResult_LocationImpl();
void InitDefaultsServiceReply_FindResult_Location();
void InitDefaultsServiceReply_FindResultImpl();
void InitDefaultsServiceReply_FindResult();
void InitDefaultsServiceReplyImpl();
void InitDefaultsServiceReply();
inline void InitDefaults() {
  InitDefaultsTxtField();
  InitDefaultsServiceRequest_Register_Location();
  InitDefaultsServiceRequest_Register();
  InitDefaultsServiceRequest_Unregister();
  InitDefaultsServiceRequest_Find();
  InitDefaultsServiceRequest();
  InitDefaultsServiceReply_FindResult_Location();
  InitDefaultsServiceReply_FindResult();
  InitDefaultsServiceReply();
}
}  // namespace protobuf_Services_2eproto
namespace directoryd {
class ServiceReply;
class ServiceReplyDefaultTypeInternal;
extern ServiceReplyDefaultTypeInternal _ServiceReply_default_instance_;
class ServiceReply_FindResult;
class ServiceReply_FindResultDefaultTypeInternal;
extern ServiceReply_FindResultDefaultTypeInternal _ServiceReply_FindResult_default_instance_;
class ServiceReply_FindResult_Location;
class ServiceReply_FindResult_LocationDefaultTypeInternal;
extern ServiceReply_FindResult_LocationDefaultTypeInternal _ServiceReply_FindResult_Location_default_instance_;
class ServiceRequest;
class ServiceRequestDefaultTypeInternal;
extern ServiceRequestDefaultTypeInternal _ServiceRequest_default_instance_;
class ServiceRequest_Find;
class ServiceRequest_FindDefaultTypeInternal;
extern ServiceRequest_FindDefaultTypeInternal _ServiceRequest_Find_default_instance_;
class ServiceRequest_Register;
class ServiceRequest_RegisterDefaultTypeInternal;
extern ServiceRequest_RegisterDefaultTypeInternal _ServiceRequest_Register_default_instance_;
class ServiceRequest_Register_Location;
class ServiceRequest_Register_LocationDefaultTypeInternal;
extern ServiceRequest_Register_LocationDefaultTypeInternal _ServiceRequest_Register_Location_default_instance_;
class ServiceRequest_Unregister;
class ServiceRequest_UnregisterDefaultTypeInternal;
extern ServiceRequest_UnregisterDefaultTypeInternal _ServiceRequest_Unregister_default_instance_;
class TxtField;
class TxtFieldDefaultTypeInternal;
extern TxtFieldDefaultTypeInternal _TxtField_default_instance_;
}  // namespace directoryd
namespace directoryd {

enum RequestType {
  REGISTER = 1,
  UNREGISTER = 2,
  FIND = 3,
  HEARTBEAT = 4
};
bool RequestType_IsValid(int value);
const RequestType RequestType_MIN = REGISTER;
const RequestType RequestType_MAX = HEARTBEAT;
const int RequestType_ARRAYSIZE = RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestType_descriptor();
inline const ::std::string& RequestType_Name(RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestType_descriptor(), value);
}
inline bool RequestType_Parse(
    const ::std::string& name, RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestType>(
    RequestType_descriptor(), name, value);
}
// ===================================================================

class TxtField : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:directoryd.TxtField) */ {
 public:
  TxtField();
  virtual ~TxtField();

  TxtField(const TxtField& from);

  inline TxtField& operator=(const TxtField& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxtField(TxtField&& from) noexcept
    : TxtField() {
    *this = ::std::move(from);
  }

  inline TxtField& operator=(TxtField&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxtField& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxtField* internal_default_instance() {
    return reinterpret_cast<const TxtField*>(
               &_TxtField_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(TxtField* other);
  friend void swap(TxtField& a, TxtField& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxtField* New() const PROTOBUF_FINAL { return New(NULL); }

  TxtField* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxtField& from);
  void MergeFrom(const TxtField& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxtField* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:directoryd.TxtField)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_Services_2eproto::TableStruct;
  friend void ::protobuf_Services_2eproto::InitDefaultsTxtFieldImpl();
};
// -------------------------------------------------------------------

class ServiceRequest_Register_Location : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:directoryd.ServiceRequest.Register.Location) */ {
 public:
  ServiceRequest_Register_Location();
  virtual ~ServiceRequest_Register_Location();

  ServiceRequest_Register_Location(const ServiceRequest_Register_Location& from);

  inline ServiceRequest_Register_Location& operator=(const ServiceRequest_Register_Location& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServiceRequest_Register_Location(ServiceRequest_Register_Location&& from) noexcept
    : ServiceRequest_Register_Location() {
    *this = ::std::move(from);
  }

  inline ServiceRequest_Register_Location& operator=(ServiceRequest_Register_Location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceRequest_Register_Location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServiceRequest_Register_Location* internal_default_instance() {
    return reinterpret_cast<const ServiceRequest_Register_Location*>(
               &_ServiceRequest_Register_Location_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ServiceRequest_Register_Location* other);
  friend void swap(ServiceRequest_Register_Location& a, ServiceRequest_Register_Location& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServiceRequest_Register_Location* New() const PROTOBUF_FINAL { return New(NULL); }

  ServiceRequest_Register_Location* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServiceRequest_Register_Location& from);
  void MergeFrom(const ServiceRequest_Register_Location& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServiceRequest_Register_Location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string resource = 3;
  bool has_resource() const;
  void clear_resource();
  static const int kResourceFieldNumber = 3;
  const ::std::string& resource() const;
  void set_resource(const ::std::string& value);
  #if LANG_CXX11
  void set_resource(::std::string&& value);
  #endif
  void set_resource(const char* value);
  void set_resource(const char* value, size_t size);
  ::std::string* mutable_resource();
  ::std::string* release_resource();
  void set_allocated_resource(::std::string* resource);

  // optional int32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:directoryd.ServiceRequest.Register.Location)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_port();
  void clear_has_port();
  void set_has_resource();
  void clear_has_resource();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr resource_;
  ::google::protobuf::int32 port_;
  friend struct ::protobuf_Services_2eproto::TableStruct;
  friend void ::protobuf_Services_2eproto::InitDefaultsServiceRequest_Register_LocationImpl();
};
// -------------------------------------------------------------------

class ServiceRequest_Register : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:directoryd.ServiceRequest.Register) */ {
 public:
  ServiceRequest_Register();
  virtual ~ServiceRequest_Register();

  ServiceRequest_Register(const ServiceRequest_Register& from);

  inline ServiceRequest_Register& operator=(const ServiceRequest_Register& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServiceRequest_Register(ServiceRequest_Register&& from) noexcept
    : ServiceRequest_Register() {
    *this = ::std::move(from);
  }

  inline ServiceRequest_Register& operator=(ServiceRequest_Register&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceRequest_Register& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServiceRequest_Register* internal_default_instance() {
    return reinterpret_cast<const ServiceRequest_Register*>(
               &_ServiceRequest_Register_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ServiceRequest_Register* other);
  friend void swap(ServiceRequest_Register& a, ServiceRequest_Register& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServiceRequest_Register* New() const PROTOBUF_FINAL { return New(NULL); }

  ServiceRequest_Register* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServiceRequest_Register& from);
  void MergeFrom(const ServiceRequest_Register& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServiceRequest_Register* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ServiceRequest_Register_Location Location;

  // accessors -------------------------------------------------------

  // repeated .directoryd.ServiceRequest.Register.Location location = 2;
  int location_size() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  const ::directoryd::ServiceRequest_Register_Location& location(int index) const;
  ::directoryd::ServiceRequest_Register_Location* mutable_location(int index);
  ::directoryd::ServiceRequest_Register_Location* add_location();
  ::google::protobuf::RepeatedPtrField< ::directoryd::ServiceRequest_Register_Location >*
      mutable_location();
  const ::google::protobuf::RepeatedPtrField< ::directoryd::ServiceRequest_Register_Location >&
      location() const;

  // repeated .directoryd.TxtField txt = 3;
  int txt_size() const;
  void clear_txt();
  static const int kTxtFieldNumber = 3;
  const ::directoryd::TxtField& txt(int index) const;
  ::directoryd::TxtField* mutable_txt(int index);
  ::directoryd::TxtField* add_txt();
  ::google::protobuf::RepeatedPtrField< ::directoryd::TxtField >*
      mutable_txt();
  const ::google::protobuf::RepeatedPtrField< ::directoryd::TxtField >&
      txt() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:directoryd.ServiceRequest.Register)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::directoryd::ServiceRequest_Register_Location > location_;
  ::google::protobuf::RepeatedPtrField< ::directoryd::TxtField > txt_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_Services_2eproto::TableStruct;
  friend void ::protobuf_Services_2eproto::InitDefaultsServiceRequest_RegisterImpl();
};
// -------------------------------------------------------------------

class ServiceRequest_Unregister : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:directoryd.ServiceRequest.Unregister) */ {
 public:
  ServiceRequest_Unregister();
  virtual ~ServiceRequest_Unregister();

  ServiceRequest_Unregister(const ServiceRequest_Unregister& from);

  inline ServiceRequest_Unregister& operator=(const ServiceRequest_Unregister& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServiceRequest_Unregister(ServiceRequest_Unregister&& from) noexcept
    : ServiceRequest_Unregister() {
    *this = ::std::move(from);
  }

  inline ServiceRequest_Unregister& operator=(ServiceRequest_Unregister&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceRequest_Unregister& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServiceRequest_Unregister* internal_default_instance() {
    return reinterpret_cast<const ServiceRequest_Unregister*>(
               &_ServiceRequest_Unregister_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ServiceRequest_Unregister* other);
  friend void swap(ServiceRequest_Unregister& a, ServiceRequest_Unregister& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServiceRequest_Unregister* New() const PROTOBUF_FINAL { return New(NULL); }

  ServiceRequest_Unregister* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServiceRequest_Unregister& from);
  void MergeFrom(const ServiceRequest_Unregister& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServiceRequest_Unregister* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:directoryd.ServiceRequest.Unregister)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_Services_2eproto::TableStruct;
  friend void ::protobuf_Services_2eproto::InitDefaultsServiceRequest_UnregisterImpl();
};
// -------------------------------------------------------------------

class ServiceRequest_Find : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:directoryd.ServiceRequest.Find) */ {
 public:
  ServiceRequest_Find();
  virtual ~ServiceRequest_Find();

  ServiceRequest_Find(const ServiceRequest_Find& from);

  inline ServiceRequest_Find& operator=(const ServiceRequest_Find& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServiceRequest_Find(ServiceRequest_Find&& from) noexcept
    : ServiceRequest_Find() {
    *this = ::std::move(from);
  }

  inline ServiceRequest_Find& operator=(ServiceRequest_Find&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceRequest_Find& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServiceRequest_Find* internal_default_instance() {
    return reinterpret_cast<const ServiceRequest_Find*>(
               &_ServiceRequest_Find_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ServiceRequest_Find* other);
  friend void swap(ServiceRequest_Find& a, ServiceRequest_Find& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServiceRequest_Find* New() const PROTOBUF_FINAL { return New(NULL); }

  ServiceRequest_Find* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServiceRequest_Find& from);
  void MergeFrom(const ServiceRequest_Find& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServiceRequest_Find* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .directoryd.TxtField txt = 3;
  int txt_size() const;
  void clear_txt();
  static const int kTxtFieldNumber = 3;
  const ::directoryd::TxtField& txt(int index) const;
  ::directoryd::TxtField* mutable_txt(int index);
  ::directoryd::TxtField* add_txt();
  ::google::protobuf::RepeatedPtrField< ::directoryd::TxtField >*
      mutable_txt();
  const ::google::protobuf::RepeatedPtrField< ::directoryd::TxtField >&
      txt() const;

  // required string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:directoryd.ServiceRequest.Find)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::directoryd::TxtField > txt_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_Services_2eproto::TableStruct;
  friend void ::protobuf_Services_2eproto::InitDefaultsServiceRequest_FindImpl();
};
// -------------------------------------------------------------------

class ServiceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:directoryd.ServiceRequest) */ {
 public:
  ServiceRequest();
  virtual ~ServiceRequest();

  ServiceRequest(const ServiceRequest& from);

  inline ServiceRequest& operator=(const ServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServiceRequest(ServiceRequest&& from) noexcept
    : ServiceRequest() {
    *this = ::std::move(from);
  }

  inline ServiceRequest& operator=(ServiceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServiceRequest* internal_default_instance() {
    return reinterpret_cast<const ServiceRequest*>(
               &_ServiceRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ServiceRequest* other);
  friend void swap(ServiceRequest& a, ServiceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServiceRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ServiceRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServiceRequest& from);
  void MergeFrom(const ServiceRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServiceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ServiceRequest_Register Register;
  typedef ServiceRequest_Unregister Unregister;
  typedef ServiceRequest_Find Find;

  // accessors -------------------------------------------------------

  // optional .directoryd.ServiceRequest.Register register = 2;
  bool has_register_() const;
  void clear_register_();
  static const int kRegisterFieldNumber = 2;
  const ::directoryd::ServiceRequest_Register& register_() const;
  ::directoryd::ServiceRequest_Register* release_register_();
  ::directoryd::ServiceRequest_Register* mutable_register_();
  void set_allocated_register_(::directoryd::ServiceRequest_Register* register_);

  // optional .directoryd.ServiceRequest.Unregister unregister = 3;
  bool has_unregister() const;
  void clear_unregister();
  static const int kUnregisterFieldNumber = 3;
  const ::directoryd::ServiceRequest_Unregister& unregister() const;
  ::directoryd::ServiceRequest_Unregister* release_unregister();
  ::directoryd::ServiceRequest_Unregister* mutable_unregister();
  void set_allocated_unregister(::directoryd::ServiceRequest_Unregister* unregister);

  // optional .directoryd.ServiceRequest.Find find = 4;
  bool has_find() const;
  void clear_find();
  static const int kFindFieldNumber = 4;
  const ::directoryd::ServiceRequest_Find& find() const;
  ::directoryd::ServiceRequest_Find* release_find();
  ::directoryd::ServiceRequest_Find* mutable_find();
  void set_allocated_find(::directoryd::ServiceRequest_Find* find);

  // required .directoryd.RequestType type = 1 [default = HEARTBEAT];
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::directoryd::RequestType type() const;
  void set_type(::directoryd::RequestType value);

  // @@protoc_insertion_point(class_scope:directoryd.ServiceRequest)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_register_();
  void clear_has_register_();
  void set_has_unregister();
  void clear_has_unregister();
  void set_has_find();
  void clear_has_find();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::directoryd::ServiceRequest_Register* register__;
  ::directoryd::ServiceRequest_Unregister* unregister_;
  ::directoryd::ServiceRequest_Find* find_;
  int type_;
  friend struct ::protobuf_Services_2eproto::TableStruct;
  friend void ::protobuf_Services_2eproto::InitDefaultsServiceRequestImpl();
};
// -------------------------------------------------------------------

class ServiceReply_FindResult_Location : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:directoryd.ServiceReply.FindResult.Location) */ {
 public:
  ServiceReply_FindResult_Location();
  virtual ~ServiceReply_FindResult_Location();

  ServiceReply_FindResult_Location(const ServiceReply_FindResult_Location& from);

  inline ServiceReply_FindResult_Location& operator=(const ServiceReply_FindResult_Location& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServiceReply_FindResult_Location(ServiceReply_FindResult_Location&& from) noexcept
    : ServiceReply_FindResult_Location() {
    *this = ::std::move(from);
  }

  inline ServiceReply_FindResult_Location& operator=(ServiceReply_FindResult_Location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceReply_FindResult_Location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServiceReply_FindResult_Location* internal_default_instance() {
    return reinterpret_cast<const ServiceReply_FindResult_Location*>(
               &_ServiceReply_FindResult_Location_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ServiceReply_FindResult_Location* other);
  friend void swap(ServiceReply_FindResult_Location& a, ServiceReply_FindResult_Location& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServiceReply_FindResult_Location* New() const PROTOBUF_FINAL { return New(NULL); }

  ServiceReply_FindResult_Location* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServiceReply_FindResult_Location& from);
  void MergeFrom(const ServiceReply_FindResult_Location& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServiceReply_FindResult_Location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional string resource = 3;
  bool has_resource() const;
  void clear_resource();
  static const int kResourceFieldNumber = 3;
  const ::std::string& resource() const;
  void set_resource(const ::std::string& value);
  #if LANG_CXX11
  void set_resource(::std::string&& value);
  #endif
  void set_resource(const char* value);
  void set_resource(const char* value, size_t size);
  ::std::string* mutable_resource();
  ::std::string* release_resource();
  void set_allocated_resource(::std::string* resource);

  // optional int32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:directoryd.ServiceReply.FindResult.Location)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_port();
  void clear_has_port();
  void set_has_resource();
  void clear_has_resource();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr resource_;
  ::google::protobuf::int32 port_;
  friend struct ::protobuf_Services_2eproto::TableStruct;
  friend void ::protobuf_Services_2eproto::InitDefaultsServiceReply_FindResult_LocationImpl();
};
// -------------------------------------------------------------------

class ServiceReply_FindResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:directoryd.ServiceReply.FindResult) */ {
 public:
  ServiceReply_FindResult();
  virtual ~ServiceReply_FindResult();

  ServiceReply_FindResult(const ServiceReply_FindResult& from);

  inline ServiceReply_FindResult& operator=(const ServiceReply_FindResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServiceReply_FindResult(ServiceReply_FindResult&& from) noexcept
    : ServiceReply_FindResult() {
    *this = ::std::move(from);
  }

  inline ServiceReply_FindResult& operator=(ServiceReply_FindResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceReply_FindResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServiceReply_FindResult* internal_default_instance() {
    return reinterpret_cast<const ServiceReply_FindResult*>(
               &_ServiceReply_FindResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ServiceReply_FindResult* other);
  friend void swap(ServiceReply_FindResult& a, ServiceReply_FindResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServiceReply_FindResult* New() const PROTOBUF_FINAL { return New(NULL); }

  ServiceReply_FindResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServiceReply_FindResult& from);
  void MergeFrom(const ServiceReply_FindResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServiceReply_FindResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ServiceReply_FindResult_Location Location;

  // accessors -------------------------------------------------------

  // repeated .directoryd.TxtField txt = 2;
  int txt_size() const;
  void clear_txt();
  static const int kTxtFieldNumber = 2;
  const ::directoryd::TxtField& txt(int index) const;
  ::directoryd::TxtField* mutable_txt(int index);
  ::directoryd::TxtField* add_txt();
  ::google::protobuf::RepeatedPtrField< ::directoryd::TxtField >*
      mutable_txt();
  const ::google::protobuf::RepeatedPtrField< ::directoryd::TxtField >&
      txt() const;

  // required .directoryd.ServiceReply.FindResult.Location location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::directoryd::ServiceReply_FindResult_Location& location() const;
  ::directoryd::ServiceReply_FindResult_Location* release_location();
  ::directoryd::ServiceReply_FindResult_Location* mutable_location();
  void set_allocated_location(::directoryd::ServiceReply_FindResult_Location* location);

  // @@protoc_insertion_point(class_scope:directoryd.ServiceReply.FindResult)
 private:
  void set_has_location();
  void clear_has_location();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::directoryd::TxtField > txt_;
  ::directoryd::ServiceReply_FindResult_Location* location_;
  friend struct ::protobuf_Services_2eproto::TableStruct;
  friend void ::protobuf_Services_2eproto::InitDefaultsServiceReply_FindResultImpl();
};
// -------------------------------------------------------------------

class ServiceReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:directoryd.ServiceReply) */ {
 public:
  ServiceReply();
  virtual ~ServiceReply();

  ServiceReply(const ServiceReply& from);

  inline ServiceReply& operator=(const ServiceReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServiceReply(ServiceReply&& from) noexcept
    : ServiceReply() {
    *this = ::std::move(from);
  }

  inline ServiceReply& operator=(ServiceReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServiceReply* internal_default_instance() {
    return reinterpret_cast<const ServiceReply*>(
               &_ServiceReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ServiceReply* other);
  friend void swap(ServiceReply& a, ServiceReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServiceReply* New() const PROTOBUF_FINAL { return New(NULL); }

  ServiceReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServiceReply& from);
  void MergeFrom(const ServiceReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServiceReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ServiceReply_FindResult FindResult;

  // accessors -------------------------------------------------------

  // repeated .directoryd.ServiceReply.FindResult findresult = 4;
  int findresult_size() const;
  void clear_findresult();
  static const int kFindresultFieldNumber = 4;
  const ::directoryd::ServiceReply_FindResult& findresult(int index) const;
  ::directoryd::ServiceReply_FindResult* mutable_findresult(int index);
  ::directoryd::ServiceReply_FindResult* add_findresult();
  ::google::protobuf::RepeatedPtrField< ::directoryd::ServiceReply_FindResult >*
      mutable_findresult();
  const ::google::protobuf::RepeatedPtrField< ::directoryd::ServiceReply_FindResult >&
      findresult() const;

  // optional string result = 3;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 3;
  const ::std::string& result() const;
  void set_result(const ::std::string& value);
  #if LANG_CXX11
  void set_result(::std::string&& value);
  #endif
  void set_result(const char* value);
  void set_result(const char* value, size_t size);
  ::std::string* mutable_result();
  ::std::string* release_result();
  void set_allocated_result(::std::string* result);

  // required .directoryd.RequestType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::directoryd::RequestType type() const;
  void set_type(::directoryd::RequestType value);

  // required bool success = 2 [default = true];
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 2;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:directoryd.ServiceReply)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_success();
  void clear_has_success();
  void set_has_result();
  void clear_has_result();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::directoryd::ServiceReply_FindResult > findresult_;
  ::google::protobuf::internal::ArenaStringPtr result_;
  int type_;
  bool success_;
  friend struct ::protobuf_Services_2eproto::TableStruct;
  friend void ::protobuf_Services_2eproto::InitDefaultsServiceReplyImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TxtField

// required string key = 1;
inline bool TxtField::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxtField::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxtField::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxtField::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& TxtField::key() const {
  // @@protoc_insertion_point(field_get:directoryd.TxtField.key)
  return key_.GetNoArena();
}
inline void TxtField::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:directoryd.TxtField.key)
}
#if LANG_CXX11
inline void TxtField::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:directoryd.TxtField.key)
}
#endif
inline void TxtField::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:directoryd.TxtField.key)
}
inline void TxtField::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:directoryd.TxtField.key)
}
inline ::std::string* TxtField::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:directoryd.TxtField.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxtField::release_key() {
  // @@protoc_insertion_point(field_release:directoryd.TxtField.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxtField::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:directoryd.TxtField.key)
}

// required string value = 2;
inline bool TxtField::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxtField::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxtField::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxtField::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& TxtField::value() const {
  // @@protoc_insertion_point(field_get:directoryd.TxtField.value)
  return value_.GetNoArena();
}
inline void TxtField::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:directoryd.TxtField.value)
}
#if LANG_CXX11
inline void TxtField::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:directoryd.TxtField.value)
}
#endif
inline void TxtField::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:directoryd.TxtField.value)
}
inline void TxtField::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:directoryd.TxtField.value)
}
inline ::std::string* TxtField::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:directoryd.TxtField.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxtField::release_value() {
  // @@protoc_insertion_point(field_release:directoryd.TxtField.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxtField::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:directoryd.TxtField.value)
}

// -------------------------------------------------------------------

// ServiceRequest_Register_Location

// required string type = 1;
inline bool ServiceRequest_Register_Location::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceRequest_Register_Location::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceRequest_Register_Location::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceRequest_Register_Location::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& ServiceRequest_Register_Location::type() const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceRequest.Register.Location.type)
  return type_.GetNoArena();
}
inline void ServiceRequest_Register_Location::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:directoryd.ServiceRequest.Register.Location.type)
}
#if LANG_CXX11
inline void ServiceRequest_Register_Location::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:directoryd.ServiceRequest.Register.Location.type)
}
#endif
inline void ServiceRequest_Register_Location::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:directoryd.ServiceRequest.Register.Location.type)
}
inline void ServiceRequest_Register_Location::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:directoryd.ServiceRequest.Register.Location.type)
}
inline ::std::string* ServiceRequest_Register_Location::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceRequest.Register.Location.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceRequest_Register_Location::release_type() {
  // @@protoc_insertion_point(field_release:directoryd.ServiceRequest.Register.Location.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceRequest_Register_Location::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:directoryd.ServiceRequest.Register.Location.type)
}

// optional int32 port = 2;
inline bool ServiceRequest_Register_Location::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceRequest_Register_Location::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceRequest_Register_Location::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceRequest_Register_Location::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 ServiceRequest_Register_Location::port() const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceRequest.Register.Location.port)
  return port_;
}
inline void ServiceRequest_Register_Location::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:directoryd.ServiceRequest.Register.Location.port)
}

// optional string resource = 3;
inline bool ServiceRequest_Register_Location::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceRequest_Register_Location::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceRequest_Register_Location::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceRequest_Register_Location::clear_resource() {
  resource_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_resource();
}
inline const ::std::string& ServiceRequest_Register_Location::resource() const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceRequest.Register.Location.resource)
  return resource_.GetNoArena();
}
inline void ServiceRequest_Register_Location::set_resource(const ::std::string& value) {
  set_has_resource();
  resource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:directoryd.ServiceRequest.Register.Location.resource)
}
#if LANG_CXX11
inline void ServiceRequest_Register_Location::set_resource(::std::string&& value) {
  set_has_resource();
  resource_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:directoryd.ServiceRequest.Register.Location.resource)
}
#endif
inline void ServiceRequest_Register_Location::set_resource(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_resource();
  resource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:directoryd.ServiceRequest.Register.Location.resource)
}
inline void ServiceRequest_Register_Location::set_resource(const char* value, size_t size) {
  set_has_resource();
  resource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:directoryd.ServiceRequest.Register.Location.resource)
}
inline ::std::string* ServiceRequest_Register_Location::mutable_resource() {
  set_has_resource();
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceRequest.Register.Location.resource)
  return resource_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceRequest_Register_Location::release_resource() {
  // @@protoc_insertion_point(field_release:directoryd.ServiceRequest.Register.Location.resource)
  clear_has_resource();
  return resource_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceRequest_Register_Location::set_allocated_resource(::std::string* resource) {
  if (resource != NULL) {
    set_has_resource();
  } else {
    clear_has_resource();
  }
  resource_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), resource);
  // @@protoc_insertion_point(field_set_allocated:directoryd.ServiceRequest.Register.Location.resource)
}

// -------------------------------------------------------------------

// ServiceRequest_Register

// required string name = 1;
inline bool ServiceRequest_Register::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceRequest_Register::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceRequest_Register::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceRequest_Register::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ServiceRequest_Register::name() const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceRequest.Register.name)
  return name_.GetNoArena();
}
inline void ServiceRequest_Register::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:directoryd.ServiceRequest.Register.name)
}
#if LANG_CXX11
inline void ServiceRequest_Register::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:directoryd.ServiceRequest.Register.name)
}
#endif
inline void ServiceRequest_Register::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:directoryd.ServiceRequest.Register.name)
}
inline void ServiceRequest_Register::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:directoryd.ServiceRequest.Register.name)
}
inline ::std::string* ServiceRequest_Register::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceRequest.Register.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceRequest_Register::release_name() {
  // @@protoc_insertion_point(field_release:directoryd.ServiceRequest.Register.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceRequest_Register::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:directoryd.ServiceRequest.Register.name)
}

// repeated .directoryd.ServiceRequest.Register.Location location = 2;
inline int ServiceRequest_Register::location_size() const {
  return location_.size();
}
inline void ServiceRequest_Register::clear_location() {
  location_.Clear();
}
inline const ::directoryd::ServiceRequest_Register_Location& ServiceRequest_Register::location(int index) const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceRequest.Register.location)
  return location_.Get(index);
}
inline ::directoryd::ServiceRequest_Register_Location* ServiceRequest_Register::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceRequest.Register.location)
  return location_.Mutable(index);
}
inline ::directoryd::ServiceRequest_Register_Location* ServiceRequest_Register::add_location() {
  // @@protoc_insertion_point(field_add:directoryd.ServiceRequest.Register.location)
  return location_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::directoryd::ServiceRequest_Register_Location >*
ServiceRequest_Register::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:directoryd.ServiceRequest.Register.location)
  return &location_;
}
inline const ::google::protobuf::RepeatedPtrField< ::directoryd::ServiceRequest_Register_Location >&
ServiceRequest_Register::location() const {
  // @@protoc_insertion_point(field_list:directoryd.ServiceRequest.Register.location)
  return location_;
}

// repeated .directoryd.TxtField txt = 3;
inline int ServiceRequest_Register::txt_size() const {
  return txt_.size();
}
inline void ServiceRequest_Register::clear_txt() {
  txt_.Clear();
}
inline const ::directoryd::TxtField& ServiceRequest_Register::txt(int index) const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceRequest.Register.txt)
  return txt_.Get(index);
}
inline ::directoryd::TxtField* ServiceRequest_Register::mutable_txt(int index) {
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceRequest.Register.txt)
  return txt_.Mutable(index);
}
inline ::directoryd::TxtField* ServiceRequest_Register::add_txt() {
  // @@protoc_insertion_point(field_add:directoryd.ServiceRequest.Register.txt)
  return txt_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::directoryd::TxtField >*
ServiceRequest_Register::mutable_txt() {
  // @@protoc_insertion_point(field_mutable_list:directoryd.ServiceRequest.Register.txt)
  return &txt_;
}
inline const ::google::protobuf::RepeatedPtrField< ::directoryd::TxtField >&
ServiceRequest_Register::txt() const {
  // @@protoc_insertion_point(field_list:directoryd.ServiceRequest.Register.txt)
  return txt_;
}

// -------------------------------------------------------------------

// ServiceRequest_Unregister

// required string name = 1;
inline bool ServiceRequest_Unregister::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceRequest_Unregister::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceRequest_Unregister::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceRequest_Unregister::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ServiceRequest_Unregister::name() const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceRequest.Unregister.name)
  return name_.GetNoArena();
}
inline void ServiceRequest_Unregister::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:directoryd.ServiceRequest.Unregister.name)
}
#if LANG_CXX11
inline void ServiceRequest_Unregister::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:directoryd.ServiceRequest.Unregister.name)
}
#endif
inline void ServiceRequest_Unregister::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:directoryd.ServiceRequest.Unregister.name)
}
inline void ServiceRequest_Unregister::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:directoryd.ServiceRequest.Unregister.name)
}
inline ::std::string* ServiceRequest_Unregister::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceRequest.Unregister.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceRequest_Unregister::release_name() {
  // @@protoc_insertion_point(field_release:directoryd.ServiceRequest.Unregister.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceRequest_Unregister::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:directoryd.ServiceRequest.Unregister.name)
}

// -------------------------------------------------------------------

// ServiceRequest_Find

// required string type = 1;
inline bool ServiceRequest_Find::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceRequest_Find::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceRequest_Find::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceRequest_Find::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& ServiceRequest_Find::type() const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceRequest.Find.type)
  return type_.GetNoArena();
}
inline void ServiceRequest_Find::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:directoryd.ServiceRequest.Find.type)
}
#if LANG_CXX11
inline void ServiceRequest_Find::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:directoryd.ServiceRequest.Find.type)
}
#endif
inline void ServiceRequest_Find::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:directoryd.ServiceRequest.Find.type)
}
inline void ServiceRequest_Find::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:directoryd.ServiceRequest.Find.type)
}
inline ::std::string* ServiceRequest_Find::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceRequest.Find.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceRequest_Find::release_type() {
  // @@protoc_insertion_point(field_release:directoryd.ServiceRequest.Find.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceRequest_Find::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:directoryd.ServiceRequest.Find.type)
}

// optional string name = 2;
inline bool ServiceRequest_Find::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceRequest_Find::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceRequest_Find::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceRequest_Find::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ServiceRequest_Find::name() const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceRequest.Find.name)
  return name_.GetNoArena();
}
inline void ServiceRequest_Find::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:directoryd.ServiceRequest.Find.name)
}
#if LANG_CXX11
inline void ServiceRequest_Find::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:directoryd.ServiceRequest.Find.name)
}
#endif
inline void ServiceRequest_Find::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:directoryd.ServiceRequest.Find.name)
}
inline void ServiceRequest_Find::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:directoryd.ServiceRequest.Find.name)
}
inline ::std::string* ServiceRequest_Find::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceRequest.Find.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceRequest_Find::release_name() {
  // @@protoc_insertion_point(field_release:directoryd.ServiceRequest.Find.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceRequest_Find::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:directoryd.ServiceRequest.Find.name)
}

// repeated .directoryd.TxtField txt = 3;
inline int ServiceRequest_Find::txt_size() const {
  return txt_.size();
}
inline void ServiceRequest_Find::clear_txt() {
  txt_.Clear();
}
inline const ::directoryd::TxtField& ServiceRequest_Find::txt(int index) const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceRequest.Find.txt)
  return txt_.Get(index);
}
inline ::directoryd::TxtField* ServiceRequest_Find::mutable_txt(int index) {
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceRequest.Find.txt)
  return txt_.Mutable(index);
}
inline ::directoryd::TxtField* ServiceRequest_Find::add_txt() {
  // @@protoc_insertion_point(field_add:directoryd.ServiceRequest.Find.txt)
  return txt_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::directoryd::TxtField >*
ServiceRequest_Find::mutable_txt() {
  // @@protoc_insertion_point(field_mutable_list:directoryd.ServiceRequest.Find.txt)
  return &txt_;
}
inline const ::google::protobuf::RepeatedPtrField< ::directoryd::TxtField >&
ServiceRequest_Find::txt() const {
  // @@protoc_insertion_point(field_list:directoryd.ServiceRequest.Find.txt)
  return txt_;
}

// -------------------------------------------------------------------

// ServiceRequest

// required .directoryd.RequestType type = 1 [default = HEARTBEAT];
inline bool ServiceRequest::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceRequest::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceRequest::clear_type() {
  type_ = 4;
  clear_has_type();
}
inline ::directoryd::RequestType ServiceRequest::type() const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceRequest.type)
  return static_cast< ::directoryd::RequestType >(type_);
}
inline void ServiceRequest::set_type(::directoryd::RequestType value) {
  assert(::directoryd::RequestType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:directoryd.ServiceRequest.type)
}

// optional .directoryd.ServiceRequest.Register register = 2;
inline bool ServiceRequest::has_register_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceRequest::set_has_register_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceRequest::clear_has_register_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceRequest::clear_register_() {
  if (register__ != NULL) register__->Clear();
  clear_has_register_();
}
inline const ::directoryd::ServiceRequest_Register& ServiceRequest::register_() const {
  const ::directoryd::ServiceRequest_Register* p = register__;
  // @@protoc_insertion_point(field_get:directoryd.ServiceRequest.register)
  return p != NULL ? *p : *reinterpret_cast<const ::directoryd::ServiceRequest_Register*>(
      &::directoryd::_ServiceRequest_Register_default_instance_);
}
inline ::directoryd::ServiceRequest_Register* ServiceRequest::release_register_() {
  // @@protoc_insertion_point(field_release:directoryd.ServiceRequest.register)
  clear_has_register_();
  ::directoryd::ServiceRequest_Register* temp = register__;
  register__ = NULL;
  return temp;
}
inline ::directoryd::ServiceRequest_Register* ServiceRequest::mutable_register_() {
  set_has_register_();
  if (register__ == NULL) {
    register__ = new ::directoryd::ServiceRequest_Register;
  }
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceRequest.register)
  return register__;
}
inline void ServiceRequest::set_allocated_register_(::directoryd::ServiceRequest_Register* register_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete register__;
  }
  if (register_) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      register_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, register_, submessage_arena);
    }
    set_has_register_();
  } else {
    clear_has_register_();
  }
  register__ = register_;
  // @@protoc_insertion_point(field_set_allocated:directoryd.ServiceRequest.register)
}

// optional .directoryd.ServiceRequest.Unregister unregister = 3;
inline bool ServiceRequest::has_unregister() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceRequest::set_has_unregister() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceRequest::clear_has_unregister() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceRequest::clear_unregister() {
  if (unregister_ != NULL) unregister_->Clear();
  clear_has_unregister();
}
inline const ::directoryd::ServiceRequest_Unregister& ServiceRequest::unregister() const {
  const ::directoryd::ServiceRequest_Unregister* p = unregister_;
  // @@protoc_insertion_point(field_get:directoryd.ServiceRequest.unregister)
  return p != NULL ? *p : *reinterpret_cast<const ::directoryd::ServiceRequest_Unregister*>(
      &::directoryd::_ServiceRequest_Unregister_default_instance_);
}
inline ::directoryd::ServiceRequest_Unregister* ServiceRequest::release_unregister() {
  // @@protoc_insertion_point(field_release:directoryd.ServiceRequest.unregister)
  clear_has_unregister();
  ::directoryd::ServiceRequest_Unregister* temp = unregister_;
  unregister_ = NULL;
  return temp;
}
inline ::directoryd::ServiceRequest_Unregister* ServiceRequest::mutable_unregister() {
  set_has_unregister();
  if (unregister_ == NULL) {
    unregister_ = new ::directoryd::ServiceRequest_Unregister;
  }
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceRequest.unregister)
  return unregister_;
}
inline void ServiceRequest::set_allocated_unregister(::directoryd::ServiceRequest_Unregister* unregister) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete unregister_;
  }
  if (unregister) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      unregister = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, unregister, submessage_arena);
    }
    set_has_unregister();
  } else {
    clear_has_unregister();
  }
  unregister_ = unregister;
  // @@protoc_insertion_point(field_set_allocated:directoryd.ServiceRequest.unregister)
}

// optional .directoryd.ServiceRequest.Find find = 4;
inline bool ServiceRequest::has_find() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceRequest::set_has_find() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceRequest::clear_has_find() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceRequest::clear_find() {
  if (find_ != NULL) find_->Clear();
  clear_has_find();
}
inline const ::directoryd::ServiceRequest_Find& ServiceRequest::find() const {
  const ::directoryd::ServiceRequest_Find* p = find_;
  // @@protoc_insertion_point(field_get:directoryd.ServiceRequest.find)
  return p != NULL ? *p : *reinterpret_cast<const ::directoryd::ServiceRequest_Find*>(
      &::directoryd::_ServiceRequest_Find_default_instance_);
}
inline ::directoryd::ServiceRequest_Find* ServiceRequest::release_find() {
  // @@protoc_insertion_point(field_release:directoryd.ServiceRequest.find)
  clear_has_find();
  ::directoryd::ServiceRequest_Find* temp = find_;
  find_ = NULL;
  return temp;
}
inline ::directoryd::ServiceRequest_Find* ServiceRequest::mutable_find() {
  set_has_find();
  if (find_ == NULL) {
    find_ = new ::directoryd::ServiceRequest_Find;
  }
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceRequest.find)
  return find_;
}
inline void ServiceRequest::set_allocated_find(::directoryd::ServiceRequest_Find* find) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete find_;
  }
  if (find) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      find = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, find, submessage_arena);
    }
    set_has_find();
  } else {
    clear_has_find();
  }
  find_ = find;
  // @@protoc_insertion_point(field_set_allocated:directoryd.ServiceRequest.find)
}

// -------------------------------------------------------------------

// ServiceReply_FindResult_Location

// optional string address = 1;
inline bool ServiceReply_FindResult_Location::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceReply_FindResult_Location::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceReply_FindResult_Location::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceReply_FindResult_Location::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& ServiceReply_FindResult_Location::address() const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceReply.FindResult.Location.address)
  return address_.GetNoArena();
}
inline void ServiceReply_FindResult_Location::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:directoryd.ServiceReply.FindResult.Location.address)
}
#if LANG_CXX11
inline void ServiceReply_FindResult_Location::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:directoryd.ServiceReply.FindResult.Location.address)
}
#endif
inline void ServiceReply_FindResult_Location::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:directoryd.ServiceReply.FindResult.Location.address)
}
inline void ServiceReply_FindResult_Location::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:directoryd.ServiceReply.FindResult.Location.address)
}
inline ::std::string* ServiceReply_FindResult_Location::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceReply.FindResult.Location.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceReply_FindResult_Location::release_address() {
  // @@protoc_insertion_point(field_release:directoryd.ServiceReply.FindResult.Location.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceReply_FindResult_Location::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:directoryd.ServiceReply.FindResult.Location.address)
}

// optional int32 port = 2;
inline bool ServiceReply_FindResult_Location::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceReply_FindResult_Location::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceReply_FindResult_Location::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceReply_FindResult_Location::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 ServiceReply_FindResult_Location::port() const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceReply.FindResult.Location.port)
  return port_;
}
inline void ServiceReply_FindResult_Location::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:directoryd.ServiceReply.FindResult.Location.port)
}

// optional string resource = 3;
inline bool ServiceReply_FindResult_Location::has_resource() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceReply_FindResult_Location::set_has_resource() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceReply_FindResult_Location::clear_has_resource() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceReply_FindResult_Location::clear_resource() {
  resource_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_resource();
}
inline const ::std::string& ServiceReply_FindResult_Location::resource() const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceReply.FindResult.Location.resource)
  return resource_.GetNoArena();
}
inline void ServiceReply_FindResult_Location::set_resource(const ::std::string& value) {
  set_has_resource();
  resource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:directoryd.ServiceReply.FindResult.Location.resource)
}
#if LANG_CXX11
inline void ServiceReply_FindResult_Location::set_resource(::std::string&& value) {
  set_has_resource();
  resource_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:directoryd.ServiceReply.FindResult.Location.resource)
}
#endif
inline void ServiceReply_FindResult_Location::set_resource(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_resource();
  resource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:directoryd.ServiceReply.FindResult.Location.resource)
}
inline void ServiceReply_FindResult_Location::set_resource(const char* value, size_t size) {
  set_has_resource();
  resource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:directoryd.ServiceReply.FindResult.Location.resource)
}
inline ::std::string* ServiceReply_FindResult_Location::mutable_resource() {
  set_has_resource();
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceReply.FindResult.Location.resource)
  return resource_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceReply_FindResult_Location::release_resource() {
  // @@protoc_insertion_point(field_release:directoryd.ServiceReply.FindResult.Location.resource)
  clear_has_resource();
  return resource_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceReply_FindResult_Location::set_allocated_resource(::std::string* resource) {
  if (resource != NULL) {
    set_has_resource();
  } else {
    clear_has_resource();
  }
  resource_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), resource);
  // @@protoc_insertion_point(field_set_allocated:directoryd.ServiceReply.FindResult.Location.resource)
}

// -------------------------------------------------------------------

// ServiceReply_FindResult

// required .directoryd.ServiceReply.FindResult.Location location = 1;
inline bool ServiceReply_FindResult::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceReply_FindResult::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceReply_FindResult::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceReply_FindResult::clear_location() {
  if (location_ != NULL) location_->Clear();
  clear_has_location();
}
inline const ::directoryd::ServiceReply_FindResult_Location& ServiceReply_FindResult::location() const {
  const ::directoryd::ServiceReply_FindResult_Location* p = location_;
  // @@protoc_insertion_point(field_get:directoryd.ServiceReply.FindResult.location)
  return p != NULL ? *p : *reinterpret_cast<const ::directoryd::ServiceReply_FindResult_Location*>(
      &::directoryd::_ServiceReply_FindResult_Location_default_instance_);
}
inline ::directoryd::ServiceReply_FindResult_Location* ServiceReply_FindResult::release_location() {
  // @@protoc_insertion_point(field_release:directoryd.ServiceReply.FindResult.location)
  clear_has_location();
  ::directoryd::ServiceReply_FindResult_Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::directoryd::ServiceReply_FindResult_Location* ServiceReply_FindResult::mutable_location() {
  set_has_location();
  if (location_ == NULL) {
    location_ = new ::directoryd::ServiceReply_FindResult_Location;
  }
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceReply.FindResult.location)
  return location_;
}
inline void ServiceReply_FindResult::set_allocated_location(::directoryd::ServiceReply_FindResult_Location* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    set_has_location();
  } else {
    clear_has_location();
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:directoryd.ServiceReply.FindResult.location)
}

// repeated .directoryd.TxtField txt = 2;
inline int ServiceReply_FindResult::txt_size() const {
  return txt_.size();
}
inline void ServiceReply_FindResult::clear_txt() {
  txt_.Clear();
}
inline const ::directoryd::TxtField& ServiceReply_FindResult::txt(int index) const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceReply.FindResult.txt)
  return txt_.Get(index);
}
inline ::directoryd::TxtField* ServiceReply_FindResult::mutable_txt(int index) {
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceReply.FindResult.txt)
  return txt_.Mutable(index);
}
inline ::directoryd::TxtField* ServiceReply_FindResult::add_txt() {
  // @@protoc_insertion_point(field_add:directoryd.ServiceReply.FindResult.txt)
  return txt_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::directoryd::TxtField >*
ServiceReply_FindResult::mutable_txt() {
  // @@protoc_insertion_point(field_mutable_list:directoryd.ServiceReply.FindResult.txt)
  return &txt_;
}
inline const ::google::protobuf::RepeatedPtrField< ::directoryd::TxtField >&
ServiceReply_FindResult::txt() const {
  // @@protoc_insertion_point(field_list:directoryd.ServiceReply.FindResult.txt)
  return txt_;
}

// -------------------------------------------------------------------

// ServiceReply

// required .directoryd.RequestType type = 1;
inline bool ServiceReply::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceReply::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceReply::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceReply::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::directoryd::RequestType ServiceReply::type() const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceReply.type)
  return static_cast< ::directoryd::RequestType >(type_);
}
inline void ServiceReply::set_type(::directoryd::RequestType value) {
  assert(::directoryd::RequestType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:directoryd.ServiceReply.type)
}

// required bool success = 2 [default = true];
inline bool ServiceReply::has_success() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceReply::set_has_success() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceReply::clear_has_success() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceReply::clear_success() {
  success_ = true;
  clear_has_success();
}
inline bool ServiceReply::success() const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceReply.success)
  return success_;
}
inline void ServiceReply::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:directoryd.ServiceReply.success)
}

// optional string result = 3;
inline bool ServiceReply::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceReply::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceReply::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceReply::clear_result() {
  result_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_result();
}
inline const ::std::string& ServiceReply::result() const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceReply.result)
  return result_.GetNoArena();
}
inline void ServiceReply::set_result(const ::std::string& value) {
  set_has_result();
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:directoryd.ServiceReply.result)
}
#if LANG_CXX11
inline void ServiceReply::set_result(::std::string&& value) {
  set_has_result();
  result_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:directoryd.ServiceReply.result)
}
#endif
inline void ServiceReply::set_result(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_result();
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:directoryd.ServiceReply.result)
}
inline void ServiceReply::set_result(const char* value, size_t size) {
  set_has_result();
  result_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:directoryd.ServiceReply.result)
}
inline ::std::string* ServiceReply::mutable_result() {
  set_has_result();
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceReply.result)
  return result_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceReply::release_result() {
  // @@protoc_insertion_point(field_release:directoryd.ServiceReply.result)
  clear_has_result();
  return result_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceReply::set_allocated_result(::std::string* result) {
  if (result != NULL) {
    set_has_result();
  } else {
    clear_has_result();
  }
  result_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), result);
  // @@protoc_insertion_point(field_set_allocated:directoryd.ServiceReply.result)
}

// repeated .directoryd.ServiceReply.FindResult findresult = 4;
inline int ServiceReply::findresult_size() const {
  return findresult_.size();
}
inline void ServiceReply::clear_findresult() {
  findresult_.Clear();
}
inline const ::directoryd::ServiceReply_FindResult& ServiceReply::findresult(int index) const {
  // @@protoc_insertion_point(field_get:directoryd.ServiceReply.findresult)
  return findresult_.Get(index);
}
inline ::directoryd::ServiceReply_FindResult* ServiceReply::mutable_findresult(int index) {
  // @@protoc_insertion_point(field_mutable:directoryd.ServiceReply.findresult)
  return findresult_.Mutable(index);
}
inline ::directoryd::ServiceReply_FindResult* ServiceReply::add_findresult() {
  // @@protoc_insertion_point(field_add:directoryd.ServiceReply.findresult)
  return findresult_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::directoryd::ServiceReply_FindResult >*
ServiceReply::mutable_findresult() {
  // @@protoc_insertion_point(field_mutable_list:directoryd.ServiceReply.findresult)
  return &findresult_;
}
inline const ::google::protobuf::RepeatedPtrField< ::directoryd::ServiceReply_FindResult >&
ServiceReply::findresult() const {
  // @@protoc_insertion_point(field_list:directoryd.ServiceReply.findresult)
  return findresult_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace directoryd

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::directoryd::RequestType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::directoryd::RequestType>() {
  return ::directoryd::RequestType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Services_2eproto__INCLUDED
